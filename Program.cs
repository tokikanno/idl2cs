using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;

namespace idl2cs
{
    class Program
    {
        enum E_ParseStatus
        {
            NONE,
            MEET_COMMENT,
            MEET_ENUM,
            MEET_INTERFACE,
        }

        static void Main(string[] args)
        {
            if (args.Length != 1)
            {
                Console.WriteLine("Usage:\n\t{0} <idl file>", Path.GetFileName(Environment.GetCommandLineArgs()[0]));
                return;
            }

            string in_filename = args[0];
            if (!File.Exists(in_filename))
            {
                Console.WriteLine("{0} not exists.", in_filename);
                return;
            }
            string out_filename = Path.ChangeExtension(in_filename, ".cs");

            try
            {
                string idl = File.ReadAllText(in_filename);
                if (idl == null || idl.Length == 0)
                {
                    Console.WriteLine("Fail reading input file.");
                    return;
                }

                #region Load regular expression from resrouce
                System.Resources.ResourceManager rm = new System.Resources.ResourceManager("idl2cs.res", Assembly.GetExecutingAssembly());
                Regex find_enum = new Regex(rm.GetString("find_enum"), RegexOptions.Compiled | RegexOptions.Multiline);
                Regex find_typedef = new Regex(rm.GetString("find_typedef"), RegexOptions.Compiled | RegexOptions.Singleline);
                Regex find_interface = new Regex(rm.GetString("find_interface"), RegexOptions.Compiled | RegexOptions.Multiline);
                Regex find_function = new Regex(rm.GetString("find_function"), RegexOptions.Compiled | RegexOptions.Multiline);
                Regex find_comment = new Regex(rm.GetString("find_comment"), RegexOptions.Compiled | RegexOptions.Multiline);
                Regex find_uuid = new Regex(rm.GetString("find_uuid"), RegexOptions.Compiled | RegexOptions.Multiline);
                Regex find_helpstring = new Regex(rm.GetString("find_helpstring"), RegexOptions.Compiled | RegexOptions.Multiline);
                #endregion
                #region Prepare mapping hash table
                Dictionary<string, string> type_def_table = new Dictionary<string, string>();
                Dictionary<string, string> type_mapping_table = new Dictionary<string, string>();
                type_mapping_table.Add("LONGLONG", "Int64");
                type_mapping_table.Add("long", "int");
                type_mapping_table.Add("unsigned long", "uint");
                type_mapping_table.Add("unsigned char", "byte");
                type_mapping_table.Add("void*", "IntPtr");
                type_mapping_table.Add("HRESULT", "int");
                #endregion

                StreamWriter w = new StreamWriter(out_filename, false);
                DateTime now = DateTime.Now;
                w.WriteLine("// Auto generated by idl2cs /(c) toki, 2009/ @ {0}", DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"));
                w.WriteLine("using System;");
                w.WriteLine("using System.Collections.Generic;");
                w.WriteLine("using System.Text;");
                w.WriteLine("using System.Runtime.InteropServices;");
                w.WriteLine("");
                w.WriteLine("namespace {0}\n{{", Path.GetFileNameWithoutExtension(in_filename));

                MatchCollection r;

                #region typedef
                Console.WriteLine("Process typedef ...");
                r = find_typedef.Matches(idl);

                foreach (Match m in r)
                {
                    try
                    {
                        string key = m.Groups["key"].Value;
                        string value = m.Groups["value"].Value;
                        //Console.WriteLine("Adding: {0} => {1}", key, value);

                        if (type_def_table.ContainsKey(key))
                        {
                            if (value.StartsWith("enum "))
                            {
                                type_def_table.Remove(key);
                                type_def_table.Add(key, "enum");
                                type_def_table.Add(value.Substring(5).Trim(), key);
                            }
                        }
                        else
                        {
                            type_def_table.Add(m.Groups["key"].Value, m.Groups["value"].Value);
                        }
                    }
                    catch (Exception)
                    {
                        Console.WriteLine("Error when add: {0} => {1}", m.Groups["key"].Value, m.Groups["value"].Value);
                    }
                }

                foreach (KeyValuePair<string, string> p in type_def_table)
                {
                    Console.WriteLine("\t{0} => {1}", p.Key, p.Value);
                }
                Console.WriteLine("Total {0} typedef processed.", r.Count);
                #endregion

                #region enum
                Console.WriteLine("Process enum ...");
                r = find_enum.Matches(idl);

                w.Write("#region enum");
                foreach (Match m in r)
                {
                    string enum_name = m.Groups["name2"].Value.Trim() == String.Empty ? m.Groups["name1"].Value.Trim() : m.Groups["name2"].Value.Trim();
                    string def_name;
                    type_def_table.TryGetValue(enum_name, out def_name);

                    if (!String.IsNullOrEmpty(def_name))
                        enum_name = def_name;

                    Console.WriteLine("\t{0}", enum_name);

                    w.WriteLine();
                    if (enum_name.EndsWith("s"))
                    {
                        w.WriteLine("// idl2cs warning: possible flag enum\n[Flags]");
                    }
                    w.WriteLine("public enum {0}\n{{{1}}}", enum_name, m.Groups["body"].Value);
                }
                w.WriteLine("#endregion");
                Console.WriteLine("Total {0} enum processed.", r.Count);
                #endregion
               
                #region interrface
                Console.WriteLine("Process interface ...");
                r = find_interface.Matches(idl);

                w.Write("\n#region interface");
                foreach (Match m in r)
                {
                    string interface_name = m.Groups["name"].Value.Trim();
                    string interface_type = m.Groups["type"].Value.Trim();
                    string interface_comtype = interface_comtype = interface_type == "IDispatch" ? "InterfaceIsIDispatch" : "InterfaceIsIUnknown";
                    string interface_attr = m.Groups["attr"].Value.Trim();
                    Console.WriteLine("Found: interface: {0} => type: {1}", interface_name, interface_type);

                    Match uuid;
                    uuid = find_uuid.Match(interface_attr);
                    Match helpstring;
                    helpstring = find_helpstring.Match(interface_attr);

                    w.WriteLine();
                    w.WriteLine("/// <summary>\n/// {0}\n/// </summary>", helpstring.Groups["value"].Value);
                    w.WriteLine(@"[ComImport, Guid(""{0}""), InterfaceType(ComInterfaceType.{1})]", uuid.Groups["value"].Value, interface_comtype);
                    w.WriteLine("public interface {0}\n{{", interface_name);

                    MatchCollection rr = find_function.Matches(m.Groups["function"].Value);
                    foreach (Match mm in rr)
                    {
                        string func_type = mm.Groups["func_type"].Value.Trim();
                        string func_name = mm.Groups["func_name"].Value.Trim();
                        Console.WriteLine("\t{0} {1}",func_type, func_name);

                        string func_native_type = string.Empty;
                        if (!type_mapping_table.TryGetValue(func_type, out func_native_type) &&
                            !type_def_table.TryGetValue(func_type, out func_native_type))
                        {
                            Console.WriteLine("[Warning] Unable to mapping {0} to c# native type.", func_type);
                            w.WriteLine("// idl2cs warning: unmapped type: {0}", func_type);
                        }
                        else
                        {
                            func_type = func_native_type;
                        }

                        w.WriteLine("[PreserveSig]\n{0} {1} ();", func_type, func_name);
                    }
                    w.WriteLine("}}", interface_name);
                }
                w.WriteLine("#endregion");
                Console.WriteLine("Total {0} interface processed.", r.Count);
                #endregion

                w.WriteLine("}");

                w.Close();
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                return;
            }

#if AUTO_DUMP_OUTPUT
            Console.WriteLine("\nDumping output file: {0}\n", out_filename);
            StreamReader o = new StreamReader(out_filename);
            while (!o.EndOfStream)
            {
                Console.WriteLine(o.ReadLine());
            }
            o.Close(); 
#endif
        }
    }
}